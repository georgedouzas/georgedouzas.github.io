---
title: "Symbolic Computation in Theoretical Physics with Python"
description: "Using SageMath and Open-Source Tools."
categories: [Physics, Computational Physics]
image: "images/computational_physics.jpg"
bibliography: references.bib
jupyter:
    kernel: SageMath-10.5
format: 
    html:
        math: true
        code-line-numbers: true
---

![](images/computational_physics.jpg)

# Introduction

Symbolic computation simplifies complex equations and models physical systems.
Python and open-source tools like SageMath make it easier to solve problems in
quantum field theory, general relativity, and more.

## Main libraries

- [SageMath](https://www.sagemath.org) 
    A comprehensive system for algebra, calculus, and numerical analysis. It’s widely used for symbolic computation in physics.
- [Cadabra](https://cadabra.science/index.html) 
    A tool for tensor calculations, especially in general relativity. It simplifies complex tensor equations.
- [EinsteinPy](https://docs.einsteinpy.org/en/latest/user_guide.html) 
    A Python library for general relativity, with tools to work with Einstein’s equations and relativistic phenomena.

## Other libraries

- [PyFeyn](https://pyfeyn2.readthedocs.io/en/latest/index.html) 
    - A Python library for generating and visualizing Feynman diagrams, used in quantum field theory.
- [PyRate](https://github.com/LSartore/pyrate) 
    - A Python library for lattice field theory and high-energy physics calculations.
- [munuSSM](https://gitlab.com/thomas.biekoetter/munussm) 
    - A Python package for studying the phenomenology of the μ-from-ν Supersymmetric Standard Model (μνSSM).
- [Wilson](https://wilson-eft.github.io/) 
    - A framework for effective field theory calculations in lattice gauge theory.
- [Flavio](https://flav-io.github.io/) 
    - A Python library focused on flavor physics, studying mesons and baryons.

# SageMath

```{sage}
#| echo: false
%display latex
```

[SageMath](https://www.sagemath.org) (@sagemath) is an open-source system that
combines many powerful mathematical software packages into one interface. It
provides tools for symbolic computation, numerical analysis, plotting, and more,
making it highly useful for both research and education in mathematics, physics,
and engineering.

## Basics

Fundamental operations, symbolic computation, and core mathematical structures.

### Arithmetic operations

It supports basic arithmetic operations:

```{sage}
# Basic arithmetic operations

((3 + 5) / 8) - 2.5 ^ 3
```

###  Symbolic expressions

It supports symbolic expressions:

```{sage}
# Symbolic variables definition

var('x y')
```

```{sage}
# Symbolic expressions simplification

expr = (x^2 + x) / x
expr.simplify_full()
```

### Calculus

SageMath provides tools for symbolic calculus such as differentiation and integration. You can compute derivatives and integrals of functions symbolically:

```{sage}
# Define function

f = x^2 + 3 * x + 2
f
```

```{sage}
# Differentiate with respect to x

diff(f, x)
```

```{sage}
# Integrate with respect to x

integrate(f, x)
```

```{sage}
# Plot of the function

plot(f, (x, -5, 5))
```

### Differential equations

SageMath can solve differential equations symbolically:

```{sage}
# Define a differential equation

y = function('y')(x)
deqn = (diff(y, x) + y == sin(x))
deqn
```

```{sage}
# Solve the differential equation

desolve(deqn, y)
```

### Linear algebra

SageMath handles matrix operations, such as addition, multiplication, and finding eigenvalues:

```{sage}
# Define matrix A

A = Matrix([[1, 2], [3, 4], [5, 6]])  
A
```

```{sage}
# Define matrix B

B = Matrix([[7, 8, 9], [9, 10, 11],])
B
```

```{sage}
# Matrix multiplication

A * B
```

```{sage}
# Define matrix C

C = Matrix([[1, 0], [0, 2]])  
C
```

```{sage}
# Eigenvalue equation

C.eigenvectors_right()
```


```{sage}
# Validation of eigenvalue equation

for eigenvalue, (eigenvector, *_), _ in C.eigenvectors_right():
    display((C, eigenvector, eigenvalue, C * eigenvector == eigenvalue * eigenvector))
```

### Group theory

SageMath includes tools for working with groups:

```{sage}
# Define the symmetric group S3

G = SymmetricGroup(3)
G
```

```{sage}
# Get the order of S3

G.order()
```

```{sage}
# List the elements of S3

[g for g in G]
```

```{sage}
# Standard representation of S3

[g.matrix() for g in G]
```

### Differentiable manifolds

SageMath allows for computations in differential geometry, including tangent
vectors, differential forms, and more:

```{sage}
# Declare the spacetime manifold M

S2 = manifolds.Sphere(2)
S2
```

```{sage}
# Spherical coordinates

S2.spherical_coordinates()
```

```{sage}
# Metric

S2.metric().display()
```

## Advanced

Exploring advanced mathematics in SageMath, including group theory, manifolds,
Lie groups, and Lie algebras. This section broadly follows
[@Keski-Vakkuri2022-mx].

### Group theory

We present the list of all groups of finite order $N \leq 8$:

#### Order N = 1

```{sage}
# Z1

Z1 = CyclicPermutationGroup(1)
Z1.list()
```

#### Order N = 2

```{sage}
# Z2

Z2 = CyclicPermutationGroup(2)
Z2.list()
```

```{sage}
# Z2 Cayley table

print(Z2.cayley_table())
```

```{sage}
# S2

S2 = SymmetricGroup(2)
S2.list()
```

```{sage}
# S2 Cayley table

print(S2.cayley_table())
```

```{sage}
# Z2, S2 isomorphic

S2.is_isomorphic(Z2)
```

#### Order N = 3

```{sage}
# Z3

Z3 = CyclicPermutationGroup(3)
Z3.list()
```

```{sage}
# Z3 Cayley table

print(Z3.cayley_table())
```

#### Order N = 4

```{sage}
# Z4

Z4 = CyclicPermutationGroup(4)
Z4.list()
```

```{sage}
# Z4 Cayley table

print(Z4.cayley_table())
```

```{sage}
# Z4 cyclic

Z4.is_cyclic()
```

```{sage}
# Klein four-group

K4G = direct_product_permgroups([Z2, Z2])
K4G.list()
```

```{sage}
# Klein four-group Cayley table

print(K4G.cayley_table())
```

```{sage}
# Klein four-group cyclic

K4G.is_cyclic()
```

#### Order N = 5

```{sage}
# Z5

Z5 = CyclicPermutationGroup(5)
Z5.list()
```

```{sage}
# Z5 Cayley table

print(Z5.cayley_table())
```

#### Order N = 6

```{sage}
# Z6

Z6 = CyclicPermutationGroup(6)
Z6.list()
```

```{sage}
# Z6 Cayley table

print(Z6.cayley_table())
```

```{sage}
# Z2 x Z3

Z2xZ3 = direct_product_permgroups([Z2, Z3])
Z2xZ3.list()
```

```{sage}
# Z2 x Z3 Cayley table

print(Z2xZ3.cayley_table())
```

```{sage}
# S3

S3 = SymmetricGroup(3)
S3.list()
```

```{sage}
# S3 Cayley table

print(S3.cayley_table())
```

```{sage}
# Z6, Z2 x Z3 isomorphic

Z6.is_isomorphic(Z2xZ3)
```

```{sage}
# S3, Z6 non-isomorphic

not S3.is_isomorphic(Z6)
```

```{sage}
# S3, Z2 x Z3 non-isomorphic

not S3.is_isomorphic(Z2xZ3)
```

```{sage}
# Z6 cyclic

Z6.is_cyclic()
```

```{sage}
# Z2 x Z3 cyclic

Z2xZ3.is_cyclic()
```

```{sage}
# S3 cyclic

not S3.is_cyclic()
```

```{sage}
# Z6 abelian

Z6.is_abelian()
```

```{sage}
# Z2 x Z3 abelian

Z2xZ3.is_abelian()
```

```{sage}
# S3 non-abelian

not S3.is_abelian()
```

#### Order N = 7

```{sage}
# Z7

Z7 = CyclicPermutationGroup(7)
Z7.list()
```

```{sage}
# Z7 Cayley table

print(Z7.cayley_table())
```

#### Order N = 8

```{sage}
# Z8

Z8 = CyclicPermutationGroup(8)
Z8.list()
```

```{sage}
# Z8 Cayley table

print(Z8.cayley_table())
```

```{sage}
# Z4 x Z2

Z4xZ2 = direct_product_permgroups([Z4, Z2])
Z4xZ2.list()
```

```{sage}
# Z4xZ2 Cayley table

print(Z4xZ2.cayley_table())
```

```{sage}
# Z2 x Z2 x Z2

Z2xZ2xZ2 = direct_product_permgroups([Z2, Z2, Z2])
Z2xZ2xZ2.list()
```

```{sage}
# Z2xZ2xZ2 Cayley table

print(Z2xZ2xZ2.cayley_table())
```

```{sage}
# D4

D4 = DihedralGroup(4)
D4.list()
```

```{sage}
# D4 Cayley table

print(D4.cayley_table())
```

```{sage}
# Q

Q = QuaternionGroup()
Q.list()
```

```{sage}
# Q Cayley table

print(Q.cayley_table())
```

```{sage}
# Z8, Z4 x Z2, Z2 x Z2 x Z2, D4, Q  non-isomorphic

from itertools import combinations
groups = [Z8, Z4xZ2, Z2xZ2xZ2, D4, Q]
for group1, group2 in combinations(groups, 2):
    if not group1.is_isomorphic(group2):
        display(f'{group1}, {group2} are not isomorphic.')
```

```{sage}
# Z8 abelian

Z8.is_abelian()
```

```{sage}
# Z4 x Z2 abelian

Z4xZ2.is_abelian()
```

```{sage}
# Z2 x Z2 x Z2 abelian

Z2xZ2xZ2.is_abelian()
```

```{sage}
# D4 non-abelian

not D4.is_abelian()
```

```{sage}
# Q non-abelian

not Q.is_abelian()
```

```{sage}
# Q subgroups

for G in Q.subgroups():
    display(G)
```

```{sage}
# Q proper subgroups

for G in Q.subgroups():
    if G.order() == 2:
        if G.is_isomorphic(Z2) and G.is_normal():
            display(f'{G} is isomorphic to {Z2} and a normal subgroup of {Q}.')
    elif G.order() == 4:
        if G.is_isomorphic(Z4) and G.is_normal():
            display(f'{G} is isomorphic to {Z4} and a normal subgroup of {Q}.')
```
